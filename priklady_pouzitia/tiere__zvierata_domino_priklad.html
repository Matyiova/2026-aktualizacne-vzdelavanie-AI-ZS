<!DOCTYPE html>
<html lang="sk">
<head>
<meta charset="UTF-8">
<title>Tiere - Zvierat√°</title>
<script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
<style>
    :root {
        --card-size: 80px;
        --card-w: calc(var(--card-size) * 2);
        --card-h: var(--card-size);
        --bg-color: #f0f2f5;
        --grid-color: #ccc;
    }

    body { 
        font-family: 'Segoe UI', sans-serif; 
        background-color: var(--bg-color); 
        margin: 0; padding: 0; 
        display: flex; flex-direction: column;
        height: 100vh; overflow: hidden; 
        user-select: none;
    }
    
    #top-bar { 
        background: white; padding: 5px 20px; border-bottom: 1px solid #ccc; 
        display: flex; justify-content: space-between; align-items: center; 
        height: 60px; flex-shrink: 0; z-index: 200; box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    .game-info h2 { margin: 0; font-size: 1.1rem; color: #333; }
    .game-info span { font-size: 0.8rem; color: #777; }
    
    #controls { display: flex; gap: 15px; align-items: center; }
    
    .ctrl-group { display: flex; flex-direction: column; gap: 2px; align-items: center; }
    .ctrl-group-label { font-size: 10px; color: #888; text-transform: uppercase; font-weight: bold; }
    .ctrl-row { display: flex; gap: 2px; }

    .btn-ctrl { 
        background: #e1e4e8; border: 1px solid #ced4da; padding: 2px 8px; border-radius: 3px; 
        cursor: pointer; font-weight: bold; color: #333; font-size: 11px; min-width: 25px;
    }
    .btn-ctrl:hover { background: #d1d4d8; border-color: #adb5bd; }
    .btn-ctrl.add { background-color: #e8f5e9; color: #1b5e20; }
    .btn-ctrl.del { background-color: #fbe9e7; color: #b71c1c; }
    
    .btn-action {
        background: #3498db; color: white; border: none; padding: 8px 15px; 
        border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 0.9rem;
    }
    .btn-action:hover { background: #2980b9; }

    #score-display { padding: 5px 10px; background: #eee; border-radius: 4px; font-weight: bold; color: #2c3e50; }

    #content-wrapper {
        display: flex; flex: 1; overflow: hidden; position: relative;
    }

    #container { 
        flex: 1; overflow: auto; position: relative; background: #e8e8e8;
    }

    #game-area { 
        position: relative; 
        width: 1200px; height: 800px; 
        background-color: #e3e3e3; 
        background-image: linear-gradient(var(--grid-color) 1px, transparent 1px), linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
        background-size: var(--card-size) var(--card-size);
        background-position: -1px -1px;
        transition: width 0.3s, height 0.3s;
    }

    .domino {
        display: flex; 
        width: var(--card-w); height: var(--card-h);
        background: white; border: 2px solid #444; border-radius: 6px;
        position: absolute; 
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        box-sizing: border-box; touch-action: none; z-index: 10;
        cursor: grab;
        transition: left 0.1s, top 0.1s, transform 0.2s;
    }
    .domino:active { cursor: grabbing; z-index: 1000 !important; transform: scale(1.02); }

    .half {
        flex: 1; display: flex; align-items: center; justify-content: center;
        padding: 4px; text-align: center; font-weight: 600; font-size: 14px;
        overflow: hidden; word-wrap: break-word; line-height: 1.1;
    }
    /* Upraven√° ƒças≈•: pridan√© font-weight: 800 pre siv√© pole */
    .half[data-type="term"] { background-color: #d0d0d0; color: #000; font-weight: 800; }
    .half[data-type="def"]  { background-color: #fff; color: #000; }
    .domino > .half:first-child { border-right: 1px solid #444; }

    /* Rot√°cie */
    .domino[data-rot="0"] { flex-direction: row; width: var(--card-w); height: var(--card-h); }
    .domino[data-rot="0"] > .half:first-child { border-right: 2px solid #444; border-bottom: none; }

    .domino[data-rot="1"] { flex-direction: column; width: var(--card-h); height: var(--card-w); }
    .domino[data-rot="1"] > .half:first-child { border-right: none; border-bottom: 2px solid #444; }

    .domino[data-rot="2"] { flex-direction: row-reverse; width: var(--card-w); height: var(--card-h); }
    .domino[data-rot="2"] > .half:last-child { border-right: 2px solid #444; border-left: none; }
    .domino[data-rot="2"] > .half:first-child { border: none; }

    .domino[data-rot="3"] { flex-direction: column-reverse; width: var(--card-h); height: var(--card-w); }
    .domino[data-rot="3"] > .half:last-child { border-bottom: 2px solid #444; border-top: none; }
    .domino[data-rot="3"] > .half:first-child { border: none; }

    .correct-match { background-color: #d4edda !important; color: #155724 !important; }
    .domino.connected { border-color: #28a745; box-shadow: 0 0 5px #28a745; }

    /* Sidebar Deck */
    #deck-container {
        width: 240px; background: white; border-left: 4px solid #ddd; 
        display: flex; flex-direction: column; flex-shrink: 0; z-index: 100;
        box-shadow: -5px 0 15px rgba(0,0,0,0.05); height: 100%;
    }
    #deck-header { padding: 10px 15px; background: #f9f9f9; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; font-size: 0.9rem; flex-shrink: 0; }
    #deck { padding: 15px; overflow-y: auto; overflow-x: hidden; display: flex; flex-direction: column; align-items: center; gap: 15px; flex: 1; }
    #deck .domino { position: relative; left: auto !important; top: auto !important; transform: none !important; flex-shrink: 0; }

    /* Modal */
    #victory-modal {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.85); z-index: 3000;
        display: none; justify-content: center; align-items: center;
        flex-direction: column; color: white;
    }
    #victory-modal h1 { font-size: 3rem; margin-bottom: 20px; }
    .modal-btns { display: flex; gap: 20px; }
    .btn-modal { padding: 15px 30px; font-size: 1.1rem; cursor: pointer; border: none; border-radius: 5px; font-weight: bold; }
    .btn-restart { background: #27ae60; color: white; }
    .btn-check { background: #fff; color: #333; }
    .btn-photo { background: #3498db; color: white; }

</style>
</head>
<body>

<div id="victory-modal">
    <h1>üéâ Hra je dokonƒçen√°! üéâ</h1>
    <p>V≈°etky karty s√∫ umiestnen√© a spr√°vne prepojen√©.</p>
    <div class="modal-btns">
        <button class="btn-modal btn-restart" onclick="location.reload()">Hra≈• znova</button>
        <button class="btn-modal btn-photo" onclick="exportGameArea()">üì∏ Ulo≈æi≈• ako obr√°zok</button>
        <button class="btn-modal btn-check" onclick="closeVictory()">üëÅÔ∏è Skontrolova≈• plochu</button>
    </div>
</div>

<div id="top-bar">
    <div class="game-info">
        <h2>Tiere - Zvierat√°</h2>
        <span>Autor: Mgr. Erika Matyiov√° (2026)</span>
    </div>
    
    <div id="controls">
        <button class="btn-action" onclick="exportGameArea()" title="Vy≈æaduje internet">üì∏ Ulo≈æi≈• plochu</button>
        
        <div class="ctrl-group">
            <span class="ctrl-group-label">Vodorovne</span>
            <div class="ctrl-row">
                <button class="btn-ctrl add" title="Prida≈• stƒ∫pec vƒæavo" onclick="modifyGrid('left', 1)">+ ‚ù∞</button>
                <button class="btn-ctrl del" title="Odobra≈• stƒ∫pec zƒæava" onclick="modifyGrid('left', -1)">- ‚ù∞</button>
                <span style="border-right:1px solid #ccc; margin:0 2px;"></span>
                <button class="btn-ctrl del" title="Odobra≈• stƒ∫pec sprava" onclick="modifyGrid('right', -1)">‚ù± -</button>
                <button class="btn-ctrl add" title="Prida≈• stƒ∫pec vpravo" onclick="modifyGrid('right', 1)">‚ù± +</button>
            </div>
        </div>

        <div class="ctrl-group">
            <span class="ctrl-group-label">Zvisle</span>
            <div class="ctrl-row">
                <button class="btn-ctrl add" title="Prida≈• riadok hore" onclick="modifyGrid('top', 1)">+ ‚ü∞</button>
                <button class="btn-ctrl del" title="Odobra≈• riadok zhora" onclick="modifyGrid('top', -1)">- ‚ü∞</button>
                <span style="border-right:1px solid #ccc; margin:0 2px;"></span>
                <button class="btn-ctrl del" title="Odobra≈• riadok zdola" onclick="modifyGrid('bottom', -1)">‚ü± -</button>
                <button class="btn-ctrl add" title="Prida≈• riadok dole" onclick="modifyGrid('bottom', 1)">‚ü± +</button>
            </div>
        </div>

        <span id="score-display">Spojenia: 0</span>
    </div>
</div>

<div id="content-wrapper">
    <div id="container">
        <div id="game-area"></div>
    </div>

    <div id="deck-container">
        <div id="deck-header">
            <strong>Z√°sobn√≠k</strong>
            <span id="cards-count">0</span>
        </div>
        <div id="deck"></div>
    </div>
</div>

<script>
    const cardsData = [{"sideA":{"text":"Katze","type":"term"},"sideB":{"text":"maƒçka","type":"def"},"id":1},{"sideA":{"text":"kr√°lik","type":"def"},"sideB":{"text":"Ente","type":"term"},"id":10},{"sideA":{"text":"Huhn","type":"term"},"sideB":{"text":"kura","type":"def"},"id":6},{"sideA":{"text":"Ente","type":"term"},"sideB":{"text":"kaƒçka","type":"def"},"id":4},{"sideA":{"text":"kaƒçka","type":"def"},"sideB":{"text":"Gans","type":"term"},"id":11},{"sideA":{"text":"my≈°","type":"def"},"sideB":{"text":"Kaninchen","type":"term"},"id":9},{"sideA":{"text":"kura","type":"def"},"sideB":{"text":"Hund","type":"term"},"id":13},{"sideA":{"text":"maƒçka","type":"def"},"sideB":{"text":"Maus","type":"term"},"id":8},{"sideA":{"text":"Gans","type":"term"},"sideB":{"text":"hus","type":"def"},"id":5},{"sideA":{"text":"Kaninchen","type":"term"},"sideB":{"text":"kr√°lik","type":"def"},"id":3},{"sideA":{"text":"pes","type":"def"},"sideB":{"text":"Katze","type":"term"},"id":7},{"sideA":{"text":"Hund","type":"term"},"sideB":{"text":"pes","type":"def"},"id":0},{"sideA":{"text":"Maus","type":"term"},"sideB":{"text":"my≈°","type":"def"},"id":2},{"sideA":{"text":"hus","type":"def"},"sideB":{"text":"Huhn","type":"term"},"id":12}];
    const pairsData = [{"term":"Hund","def":"pes"},{"term":"Katze","def":"maƒçka"},{"term":"Maus","def":"my≈°"},{"term":"Kaninchen","def":"kr√°lik"},{"term":"Ente","def":"kaƒçka"},{"term":"Gans","def":"hus"},{"term":"Huhn","def":"kura"}];
    const GRID_SIZE = 80;

    const gameArea = document.getElementById('game-area');
    const container = document.getElementById('container');
    const deck = document.getElementById('deck');
    const cardsCountEl = document.getElementById('cards-count');
    const victoryModal = document.getElementById('victory-modal');

    let placedCards = [];
    let gameFinished = false;

    function init() {
        cardsData.forEach(data => createCardElement(data));
        updateDeckStatus();
    }

    function createCardElement(data) {
        const el = document.createElement('div');
        el.className = 'domino';
        el.id = 'card-' + data.id;
        el.dataset.rot = 0;
        el.dataset.id = data.id;
        
        const halfA = document.createElement('div');
        halfA.className = 'half';
        halfA.dataset.type = data.sideA.type;
        halfA.innerText = data.sideA.text;

        const halfB = document.createElement('div');
        halfB.className = 'half';
        halfB.dataset.type = data.sideB.type;
        halfB.innerText = data.sideB.text;

        el.appendChild(halfA);
        el.appendChild(halfB);
        el.addEventListener('mousedown', startDrag);
        deck.appendChild(el);
    }

    function updateDeckStatus() {
        const count = deck.children.length;
        cardsCountEl.innerText = count;
    }

    function closeVictory() {
        victoryModal.style.display = 'none';
    }
    
    // --- VICTORY CHECK LOGIC ---
    function checkVictoryCondition() {
        if (gameFinished) return;
        
        const deckCount = deck.children.length;
        // 1. Podmienka: Z√°sobn√≠k mus√≠ by≈• pr√°zdny
        if (deckCount > 0) return;

        // 2. Podmienka: V≈°etky karty na ploche musia by≈• "connected" (zelen√©)
        // To znamen√°, ≈æe aj posledn√° karta mus√≠ by≈• pripojen√° k nieƒçomu.
        const allPlacedCards = Array.from(gameArea.children);
        
        // Ak z nejak√©ho d√¥vodu nie s√∫ ≈æiadne karty na ploche (nemalo by nasta≈• pri pr√°zdnom decku)
        if (allPlacedCards.length === 0) return;

        const allConnected = allPlacedCards.every(card => card.classList.contains('connected'));

        if (allConnected) {
             gameFinished = true;
             // Mal√© oneskorenie pre efekt
             setTimeout(() => {
                 victoryModal.style.display = 'flex';
             }, 300);
        }
    }

    // --- EXPORT TO IMAGE ---
    function exportGameArea() {
        if (typeof html2canvas === 'undefined') {
            alert("Na ulo≈æenie obr√°zka je potrebn√© pripojenie na internet (naƒç√≠tanie kni≈ænice).");
            return;
        }

        html2canvas(gameArea, {
            scrollX: 0,
            scrollY: 0,
            backgroundColor: '#e3e3e3'
        }).then(canvas => {
            const link = document.createElement('a');
            link.download = 'moje_domino_vysledok.png';
            link.href = canvas.toDataURL("image/png");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }).catch(err => {
            console.error(err);
            alert("Chyba pri vytv√°ran√≠ obr√°zka.");
        });
    }

    // --- DRAG & DROP & LOGIC ---

    let dragItem = null;
    let startX, startY, initialLeft, initialTop;
    let isDragging = false;

    function startDrag(e) {
        if (e.button !== 0) return;
        e.preventDefault();
        
        dragItem = e.currentTarget;
        startX = e.clientX;
        startY = e.clientY;
        isDragging = false;

        if (dragItem.parentElement !== deck) {
            initialLeft = parseFloat(dragItem.style.left);
            initialTop = parseFloat(dragItem.style.top);
        }

        document.addEventListener('mousemove', onDrag);
        document.addEventListener('mouseup', endDrag);
    }

    function onDrag(e) {
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;

        if (!isDragging && (Math.abs(dx) > 3 || Math.abs(dy) > 3)) {
            isDragging = true;
            if (dragItem.parentElement === deck) {
                const rect = dragItem.getBoundingClientRect();
                const areaRect = gameArea.getBoundingClientRect();
                
                dragItem.style.left = (rect.left - areaRect.left) + 'px';
                dragItem.style.top = (rect.top - areaRect.top) + 'px';
                dragItem.style.position = 'absolute';
                dragItem.style.transform = 'none';
                
                gameArea.appendChild(dragItem);
                placedCards.push(dragItem);
                
                initialLeft = parseFloat(dragItem.style.left);
                initialTop = parseFloat(dragItem.style.top);
            }
        }

        if (isDragging) {
            dragItem.style.left = (initialLeft + dx) + 'px';
            dragItem.style.top = (initialTop + dy) + 'px';
        }
    }

    function endDrag(e) {
        document.removeEventListener('mousemove', onDrag);
        document.removeEventListener('mouseup', endDrag);

        if (!isDragging) {
            if (dragItem.parentElement === gameArea) rotateCard(dragItem);
        } else {
            if (dragItem.parentElement === gameArea) {
                snapToGrid(dragItem);
                checkAllConnections();
                // Kontrola v√≠≈•azstva a≈æ po kontrole spojen√≠
                checkVictoryCondition();
            }
            updateDeckStatus();
        }
        dragItem = null;
    }

    function rotateCard(el) {
        let currentRot = parseInt(el.dataset.rot);
        let newRot = (currentRot + 1) % 4;
        el.dataset.rot = newRot;
        snapToGrid(el);
        checkAllConnections();
        checkVictoryCondition();
    }

    function snapToGrid(el) {
        let left = parseFloat(el.style.left);
        let top = parseFloat(el.style.top);
        let gridX = Math.round(left / GRID_SIZE);
        let gridY = Math.round(top / GRID_SIZE);
        el.style.left = (gridX * GRID_SIZE) + 'px';
        el.style.top = (gridY * GRID_SIZE) + 'px';
    }

    // --- GRID MANIPULATION ---
    function modifyGrid(side, direction) {
        const style = window.getComputedStyle(gameArea);
        let currentW = parseInt(style.width);
        let currentH = parseInt(style.height);

        if (side === 'right') {
            let newW = currentW + (direction * GRID_SIZE);
            if (newW >= GRID_SIZE) gameArea.style.width = newW + 'px';
        }
        if (side === 'bottom') {
            let newH = currentH + (direction * GRID_SIZE);
            if (newH >= GRID_SIZE) gameArea.style.height = newH + 'px';
        }
        if (side === 'left') {
            let newW = currentW + (direction * GRID_SIZE);
            if (newW >= GRID_SIZE) {
                gameArea.style.width = newW + 'px';
                shiftAllCards(direction * GRID_SIZE, 0);
            }
        }
        if (side === 'top') {
            let newH = currentH + (direction * GRID_SIZE);
            if (newH >= GRID_SIZE) {
                gameArea.style.height = newH + 'px';
                shiftAllCards(0, direction * GRID_SIZE);
            }
        }
    }

    function shiftAllCards(dx, dy) {
        const cards = document.querySelectorAll('#game-area .domino');
        cards.forEach(card => {
            let l = parseFloat(card.style.left);
            let t = parseFloat(card.style.top);
            card.style.left = (l + dx) + 'px';
            card.style.top = (t + dy) + 'px';
        });
    }

    // --- VALIDATION ---
    function checkAllConnections() {
        document.querySelectorAll('.half').forEach(h => h.classList.remove('correct-match'));
        document.querySelectorAll('.domino').forEach(d => d.classList.remove('connected'));

        let connectionsCount = 0;
        const cards = Array.from(gameArea.children);

        for (let i = 0; i < cards.length; i++) {
            const cardA = cards[i];
            const geomA = getCardGeometry(cardA);

            for (let j = i + 1; j < cards.length; j++) {
                const cardB = cards[j];
                const geomB = getCardGeometry(cardB);

                const match = checkAdjacency(geomA, geomB);
                if (match) {
                    if (isValidPair(match.textA, match.textB) && match.typeA !== match.typeB) {
                        highlight(match.elA, match.elB);
                        connectionsCount++;
                    }
                }
            }
        }
        document.getElementById('score-display').innerText = "Spojenia: " + connectionsCount;
    }

    function getCardGeometry(el) {
        const rot = parseInt(el.dataset.rot);
        const x = Math.round(parseFloat(el.style.left) / GRID_SIZE);
        const y = Math.round(parseFloat(el.style.top) / GRID_SIZE);
        const children = el.children; 
        const half1 = { el: children[0], text: children[0].innerText, type: children[0].dataset.type };
        const half2 = { el: children[1], text: children[1].innerText, type: children[1].dataset.type };
        let p1, p2;
        if (rot === 0) { p1 = { x: x, y: y, ...half1 }; p2 = { x: x+1, y: y, ...half2 }; }
        else if (rot === 1) { p1 = { x: x, y: y, ...half1 }; p2 = { x: x, y: y+1, ...half2 }; }
        else if (rot === 2) { p1 = { x: x+1, y: y, ...half1 }; p2 = { x: x, y: y, ...half2 }; }
        else if (rot === 3) { p1 = { x: x, y: y+1, ...half1 }; p2 = { x: x, y: y, ...half2 }; }
        return [p1, p2];
    }

    function checkAdjacency(geoA, geoB) {
        for (let pA of geoA) {
            for (let pB of geoB) {
                const dist = Math.abs(pA.x - pB.x) + Math.abs(pA.y - pB.y);
                if (dist === 1) return { textA: pA.text, typeA: pA.type, elA: pA.el, textB: pB.text, typeB: pB.type, elB: pB.el };
            }
        }
        return null;
    }

    function isValidPair(txt1, txt2) {
        return pairsData.some(p => (p.term === txt1 && p.def === txt2) || (p.term === txt2 && p.def === txt1));
    }

    function highlight(el1, el2) {
        el1.classList.add('correct-match');
        el2.classList.add('correct-match');
        el1.parentElement.classList.add('connected');
        el2.parentElement.classList.add('connected');
    }

    init();

</script>
</body>
</html>
